<script lang="ts" setup>
import { computed, PropType, ref, watch, reactive } from 'vue';
import { TriggerMode } from '../../../../types/parts/triggers/trigger';
import { LightsRunning, RunningStatus } from '../../../../types/running/running';
import { parseLightDataResult, LightValue } from '../../../../types/core';
import { trimmedLightStatusInfo } from './common';
import { CallingState, RunningLight, SourcesManager } from '../../../../types/running/light';
import { IdentityPool, ValuePool } from '../../../../types/running/pool';
import { ValueItem } from '../../../../types/common/value';
import { DataSource } from '../../../../types/parts/sources/sources';
import { DataTransmit } from '../../../../types/parts/transmits/transmits';
import { checkAndExecute, DataResult, StringResult } from '../../../../common';
import { checkDataSource, checkTransmit } from './check';
import { CandidType, CandidValue } from '@mora-light/core/types/candid';
import RunningLightWrappedSourcesVue from './sources/RunningLightWrappedSources.vue';
import RunningLightWrappedTriggersVue from './triggers/RunningLightWrappedTriggers.vue';

const parseDataResult = (
    data: DataSource[],
    transmits: DataTransmit[],
    outerValues: ValueItem[],
    dataEl?: HTMLElement,
    transmitsEl?: HTMLElement,
): {
    sourcesResult: DataResult<DataSource[]>;
    transmitsResult: DataResult<DataTransmit[]>;
} => {
    let innerValues: ValueItem[] = [];
    outerValues = [...outerValues];

    let sourcesResult: DataResult<DataSource> | undefined = undefined;

    for (let i = 0; i < data.length; i++) {
        const check = checkDataSource(data[i], true, innerValues, outerValues, dataEl);
        if (check.result.err !== undefined) sourcesResult = check.result;
        outerValues = check.outerValues!;
        innerValues = check.innerValues;
    }

    const from = parseLightDataResult(data).result;

    let transmitsResult: DataResult<DataTransmit> | undefined = undefined;

    for (let i = 0; i < transmits.length; i++) {
        const check = checkTransmit(transmits[i], from, innerValues, outerValues, transmitsEl);
        if (check.result.err !== undefined) transmitsResult = check.result;
        outerValues = check.outerValues!;
        innerValues = check.innerValues;
    }

    return {
        sourcesResult:
            sourcesResult && !sourcesResult.ok ? { err: sourcesResult.err } : { ok: data },
        transmitsResult:
            transmitsResult && !transmitsResult.ok
                ? { err: transmitsResult.err }
                : { ok: transmits },
    };
};

const parseInitTrigger = (trigger: TriggerMode | undefined): string => {
    if (trigger === undefined) return '';
    switch (trigger.type) {
        case 'button':
            return 'Click Button';
        case 'clock':
            return `Schedule (${trigger.sleep / 1000}s)`;
    }
};

const props = defineProps({
    parentGetNextSubscribeId: {
        type: Function,
        required: true,
    },
    parentTriggerRefresh: {
        type: Number,
        required: true,
    },
    parentRunningLight: {
        type: Object as PropType<RunningLight>,
        required: true,
    },
    parentSourceId: {
        type: Number,
        required: true,
    },
    argResult: {
        type: Object as PropType<StringResult<CandidValue>>,
        required: false,
    },
    status: {
        type: String as PropType<ComponentStatus>,
        required: true, // Performance state
    },
    usingRefresh: {
        type: Number,
        required: true,
    },
    using: {
        type: Object as PropType<LightsRunning>,
        required: true,
    },
    index: {
        type: Number,
        required: true,
    },
});

const dataRef = ref<HTMLElement>();

// const sourceCount = ref(0); // source count // Use the count of superiors
const sourcesRefresh = ref(0); // Trigger update and use
const triggerRefresh = ref(0); // Trigger update and use
const callingRefresh = ref(0); // Trigger update and use

// Variable pool
const outerPool = ref<ValuePool>(props.using.getOuterPool());
const innerPool = ref<ValuePool>(props.using.getInnerPool(props.index)!);
const identityPool = ref<IdentityPool>(props.using.getIdentityPool());
// External variables generated by the plug -in before removing
const outerValues = ref<ValueItem[]>(props.using.getOuterValues(props.index)!);
// Remove the plug -in content information
const light = ref<LightValue>(props.using.getLightValue(props.index)!);

const calling = ref(0); // Whether to display canister calls

let { sourcesResult: dataSourcesResult, transmitsResult: dataTransmitsResult } = parseDataResult(
    light.value.data,
    light.value.transmits,
    [...outerValues.value],
    dataRef.value,
    undefined,
);

let lightRuntimeResult: StringResult<CandidValue> | undefined = undefined;

const getNextSubscribeId = (): number => {
    return props.parentGetNextSubscribeId();
};
const nextSourceId = (): number => {
    return props.parentRunningLight.getNextSourceId();
};
const doSourcesRefresh = () => {
    // console.error("do refresh source", JSON.stringify(runningLight.value.source));
    sourcesRefresh.value = sourcesRefresh.value + 1;
    props.parentRunningLight.refreshSources();
};
const doTriggerRefresh = () => {
    // console.error("do refresh trigger");
    triggerRefresh.value = triggerRefresh.value + 1;
};
const doCallingRefresh = () => {
    // console.error("do refresh calling");
    callingRefresh.value = callingRefresh.value + 1;
};

const runningLight = reactive<RunningLight>({
    getNextSubscribeId: () => getNextSubscribeId(),
    outerPool: outerPool.value as ValuePool,
    innerPool: innerPool.value as ValuePool,
    identityPool: identityPool.value as IdentityPool,
    getNextSourceId: () => nextSourceId(),
    sources: props.parentRunningLight.sources,
    refreshSources: () => doSourcesRefresh(),
    trigger: parseInitTrigger(light.value.trigger),
    refreshTrigger: () => doTriggerRefresh(),
    calling: calling.value,
    callingStates: {},
    refreshCalling: () => doCallingRefresh(),
    finalOuterValue: props.using.getFinalOuterValues(),
});

watch(
    () => [props.usingRefresh],
    () => reload(),
);
const reload = () => {
    outerPool.value = props.using.getOuterPool();
    innerPool.value = props.using.getInnerPool(props.index)!;
    identityPool.value = props.using.getIdentityPool();
    outerValues.value = props.using.getOuterValues(props.index)!;
    light.value = props.using.getLightValue(props.index)!;

    const r = parseDataResult(
        light.value.data,
        light.value.transmits,
        [...outerValues.value],
        dataRef.value,
        undefined,
    );
    dataSourcesResult = r.sourcesResult;
    dataTransmitsResult = r.transmitsResult;

    runningLight.outerPool = outerPool.value;
    runningLight.innerPool = innerPool.value;
    runningLight.identityPool = identityPool.value;

    runningLight.finalOuterValue = props.using.getFinalOuterValues();
};

const callingStates = ref<CallingState[]>([]);

watch(
    () => callingRefresh.value,
    () => (calling.value = runningLight.calling),
);

watch(
    () => calling.value,
    () => {
        callingStates.value = [];
        const keys = Object.keys(runningLight.callingStates);
        for (let key of keys) {
            callingStates.value.push(runningLight.callingStates[key]);
        }
    },
);

// Analyze the running results of the plug -in
const lightDataType = computed<{
    result: CandidType;
    runtime?: StringResult<CandidValue>;
}>(() => parseLightDataResult(light.value.data));

const lightStatus = computed<{
    has: boolean;
    hasDataComponent: boolean;
    hasTriggerComponent: boolean;
    hasShowComponent: boolean;
}>(() => trimmedLightStatusInfo(light.value));

const onDataSourcesChanged = (r: DataResult<DataSource[]> | undefined) => {
    if (r !== undefined) dataSourcesResult = r;

    // console.error("light running onDataSourcesChanged", JSON.stringify(r));

    lightRuntimeResult = undefined;
    props.using.clean(props.index);

    if (r !== undefined && r.ok !== undefined) {
        reload(); // ? I donâ€™t know why I have to reset it here

        light.value.data = r.ok; // If it is correct, change it

        const receive = async (runtimeResult: StringResult<CandidValue>) => {
            //  Receive the calculation results
            lightRuntimeResult = runtimeResult;
            changed();
        };

        // If you are asynchronous, maybe it may be displayed and maybe
        props.using
            .pulse(
                props.index,
                runningLight.trigger,
                ['preview', 'running'].includes(props.status),
                receive,
            )
            .then((err) => {
                if (err === '') {
                    runningLight.trigger = parseInitTrigger(light.value.trigger); // After successful execution, reset
                    // console.error("reset trigger");
                    doCallingRefresh(); // Refresh correctly
                    return;
                }

                if (err.startsWith('same with last time')) {
                    runningLight.trigger = parseInitTrigger(light.value.trigger); // After successful execution, reset
                    // console.error("reset trigger");
                    doCallingRefresh(); // Refresh correctly
                    return; // The error of the same value will not be displayed
                }

                console.error('light running produce pulse error -> ', err);
            });

        return;
    }

    changed();
};

watch(
    () => runningLight.trigger,
    (nv) => {
        if (!nv) {
            onDataSourcesChanged(dataSourcesResult);
        }
    },
);

const produce = (): StringResult<CandidValue> | undefined => {
    // console.error("light running produce", props.using);

    // Check whether there is an error in the dissemination data
    if (dataSourcesResult.err !== undefined) return { err: dataSourcesResult.err.message };
    if (dataTransmitsResult.err !== undefined) return { err: dataTransmitsResult.err.message };

    return lightRuntimeResult;
};

const emit = defineEmits<{
    changed: [DataResult<CandidValue> | undefined];
}>();

const changed = () =>
    checkAndExecute(
        props.status !== 'using' || !lightStatus.value.hasDataComponent || !!dataRef.value,
        () => emit('changed', produce()),
        changed,
    );
</script>

<template>
    <div class="running-light-content">
        <!-- Show input component -->
        <div
            class="data"
            :class="{ 'has-content': lightStatus.hasDataComponent || props.status === 'using' }"
        >
            <RunningLightWrappedSourcesVue
                :argResult="props.argResult"
                :triggerRefresh="triggerRefresh"
                :status="props.status"
                :runningLight="(runningLight as any)"
                :parentSourceId="props.parentSourceId"
                :calling="calling"
                :outerValues="outerValues"
                :initial="light.data"
                @changed="onDataSourcesChanged"
                ref="dataRef"
            />
        </div>
        <!-- Show the trigger button -->
        <div
            class="trigger"
            v-if="lightStatus.hasTriggerComponent"
            :class="{
                'has-content': lightStatus.hasTriggerComponent,
                'show-dashed-border':
                    (lightStatus.hasDataComponent && lightStatus.hasTriggerComponent) ||
                    props.status === 'using',
            }"
        >
            <RunningLightWrappedTriggersVue
                :parentTriggerRefresh="props.parentTriggerRefresh"
                :parentRunningLight="props.parentRunningLight"
                :sourcesRefresh="sourcesRefresh"
                :callingRefresh="callingRefresh"
                :status="props.status"
                :runningLight="(runningLight as any)"
                :calling="calling"
                :initial="light.trigger!"
            />
        </div>
    </div>
</template>

<style lang="less" scoped>
.running-light-content {
    width: 100%;
    > div {
        &.has-content {
            padding: 5px 0;
        }
        &.show-dashed-border {
            border-top: 1px dashed #ccc;
            &:first-child {
                border-top: none;
            }
        }
    }
}
</style>
